#!/usr/bin/lua

--[[
  a    file access mode
  c    process command name (all characters from proc or user structure)
  C    file structure share count
  d    file's device character code
  D    file's major/minor device number (0x<hexadecimal>)
  f    file descriptor (always selected)
  F    file structure address (0x<hexadecimal>)
  G    file flaGs (0x<hexadecimal>; names if +fg follows)
  g    process group ID
  i    file's inode number
  K    tasK ID
  k    link count
  l    file's lock status
  L    process login name
  m    marker between repeated output
  n    file name, comment, Internet address
  N    node identifier (ox<hexadecimal>
  o    file's offset (decimal)
  p    process ID (always selected)
  P    protocol name
  r    raw device number (0x<hexadecimal>)
  R    parent process ID
  s    file's size (decimal)
  S    file's stream identification
  t    file's type
  T    TCP/TPI information, identified by prefixes (the
       `=' is part of the prefix):
           QR=<read queue size>
           QS=<send queue size>
           SO=<socket options and values> (not all dialects)
           SS=<socket states> (not all dialects)
           ST=<connection state>
           TF=<TCP flags and values> (not all dialects)
           WR=<window read size>  (not all dialects)
           WW=<window write size>  (not all dialects)
       (TCP/TPI information isn't reported for all supported
         UNIX dialects. The -h or -? help output for the
         -T option will show what TCP/TPI reporting can be
         requested.)
  u    process user ID
  z    Solaris 10 and higher zone name
  Z    SELinux security context (inhibited when SELinux is disabled)
  0    use NUL field terminator character in place of NL
  1-9  dialect-specific field identifiers (The output of -F? identifies the information to be found in dialect-specific fields.)
]]


local function printf(fmt, ...)
	io.write(string.format(fmt, ...))
end

--
-- Parse lsof output into lua tables
--

local function parse_lsof()

	local procs = {}

	local cur, proc, file

	for l in io.lines() do

		local tag, val = l:sub(1, 1), l:sub(2)

		local valn = tonumber(val)
		val = valn or val

		if tag == 'p' then
			proc = { files = {} }
			file = nil
			table.insert(procs, proc)
			cur = proc
		elseif tag == 'f' and proc then
			file = { }
			table.insert(proc.files, file)
			cur = file
		end
	
		if cur then
			cur[tag] = val
		end

		if proc then

			local skip = false

			-- skip threads

			if proc.K then
				skip = true
			end

			-- skip kernel processes

			if file and file.f == "txt" and file.t == "unknown" then
				skip = true
			end

			if skip then
				proc = nil
				file = nil
				cur = nil
				table.remove(procs)
			end
		end

	end

	return procs
end


local function print_file(f)
	for k, v in pairs(f) do
		print(k .. " " .. v)
	end
end


local function proc_find(procs, key, val)
	for _, proc in ipairs(procs) do
		if proc[key] == val then
			return proc
		end
	end
end



local procs = parse_lsof()


local function each_proc(fn)
	for _, proc in ipairs(procs) do
		fn(proc)
	end
end

local function each_file(fn)
	each_proc(function(proc)
		for _, file in ipairs(proc.files) do
			fn(proc, file)
		end
	end)
end

local function each_file_filter(key, val, fn)
	each_file(function(proc, file)
		if file[key] == val then
			fn(proc, file)
		end
	end)
end


-- Generate graph

printf("graph G {\n")
printf("	rankdir = LR;\n")
printf("	node [ shape=box, style=rounded width=0, height=0, fontname=Helvetica, fontsize=10];\n")
printf("	edge [ fontname=Helvetica, fontsize=10];\n")

-- Parent/child relationships

each_proc(function(proc)
	local proc_parent = proc_find(procs, "p", proc.R)
	if proc_parent then
		printf('	p%d [ label = "%s\\n%d" ];\n', proc.p, proc.c, proc.p)
		printf('	p%d -- p%d [ penwidth=2 weight=100 color=grey60];\n', proc.R, proc.p)
	end
end)

-- FIFOs

for _, type in ipairs( { "FIFO", "unix" } ) do
	local seen = {}
	each_file_filter("t", type, function(proc1, file1)
		each_file_filter("t", type, function(proc2, file2)
			if proc1 ~= proc2 and file1.i == file2.i then
				local name = type .. " " .. file1.i
				if not seen[name] then
					printf('	p%d -- p%d [ label = "%s:%d" color="purple" ];\n', 
						proc1.p, proc2.p, type, file1.i)
					seen[name] = true
				end
			end
		end)
	end)
end


-- sockets

for _, type in ipairs( { "IPv4", "IPv6" } ) do
	local seen = {}
	each_file_filter("t", type, function(proc1, file1)
		each_file_filter("t", type, function(proc2, file2)
			if proc1 ~= proc2 then
				local n1, n2 = file1.n, file2.n
				local from, to = n2:match("(.-)%->(.+)")
				if from and to then
					n2_rev = to .. "->" .. from
					if n1 == n2_rev then
						io.stderr:write(n1 .. "\n")
						if not seen[n1] and not seen[n2] then
							printf('	p%d -- p%d [ label = "%s" color="green" ];\n', 
								proc1.p, proc2.p, file1.P .. " " .. file1.n)
							seen[n1] = true
							seen[n2] = true
						end
					end
				end
			end
		end)
	end)
end

-- Done

print("}")

-- vi: ft=lua ts=3 sw=3

